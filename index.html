<!DOCTYPE html>

<!--[if lt IE 7]> <html class="ie6 oldie"> <![endif]-->

<!--[if IE 7]>    <html class="ie7 oldie"> <![endif]-->

<!--[if IE 8]>    <html class="ie8 oldie"> <![endif]-->

<!--[if gt IE 8]><!-->

<html>

<!--<![endif]-->

<head>

  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png" />
  <link rel="manifest" href="manifest.json" />
  <link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5" />
  <meta name="theme-color" content="#DC3521" />

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="description" content="Versão web da ferramenta Mosaico Fractal." />

  <meta name="keywords" content="mosaico,fractal,arte,matemática" />

  <meta name="author" content="Giordanna De Gregoriis" />

  <title>Mosaico Fractal Web</title>

  <link href="css/boilerplate.css" rel="stylesheet" type="text/css" />

  <link href="css/portfolioResponsive.css" rel="stylesheet" type="text/css" />

  <link href="css/portfolioStyle.css" rel="stylesheet" type="text/css" />

  <link href="css/style.css" rel="stylesheet" type="text/css" />

  <link href="css/form.css" rel="stylesheet" type="text/css" />

    <!--[if lt IE 9]>

    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>

    <![endif]-->

  <script type="text/javascript" src="js/respond.min.js"></script>

  <script type="text/javascript" src="js/jquery-3.2.1.min.js"></script>

  <script type="text/javascript" src="js/d3.min.js"></script>

  <script data-main="js/saveSvgAsPng.js" scr="js/require.js"></script>

  <script type="text/javascript" src="js/saveSvgAsPng.js"></script>

</head>

  <body>

    <div class="gridContainer">

      <header class="fluid">

        <a href="http://gior.hol.es/" title="Home">

          <figure class="fluid logo textStyle"><img src="android-chrome-256x256.png" alt="logo do site" width="30px" /> HOME</figure>

        </a>

        <h1 class="fluid mainHeading">Mosaico <b>Fractal</b></h1>

        <h6 class="fluid mainTagline textStyle">Crie imagens artísticas com a versão web da ferramenta Mosaico Fractal (código-fonte: <a href="https://bitbucket.org/giordanna/mosaico-fractal" target="_blank">desktop</a> | <a href="https://bitbucket.org/giordanna/mosaico-fractal-web" target="_blank">web</a>).</h6>

        <p class="fluid">O programa preenche um espaço utilizando estampas e utiliza a função zeta de Hurwitz para controlar suas áreas, assim permitindo que estas estampas sejam inseridas no espaço e por fim apresentando um resultado que se assemelha a um fractal geométrico, sendo também esteticamente agradável. Caso tenha interesse no estudo feito a cerca desta técnica, acesse o meu <a href="http://gior.hol.es/docs/degregoriis2017utilizacao.pdf" target="_blank"><b>TCC</b></a>.</p>

      </header>

      <article class="fluid">

        <section class="fluid">
          <center>

            <div class="form-style-6" id="formulario">
              <label for="selectEstampa"><p>Estampa desejada para o preenchimento do espaço:</p></label>
              <select id="selectEstampa" name="selectEstampa" onchange="resetarFundo(selectFundo.selectedIndex)" autocomplete="off">
                <option value="estampaCirculo">Círculos</option>
                <option value="estampaQuadrado">Quadrados</option>
                <option value="estampaTriangulo">Triângulos</option>
              </select>

              <label for="selectFundo"><p>Fundo de preenchimento atualmente escolhido:</p></label>
              <select id="selectFundo" name="selectFundo" onchange="mudarFundo(this.selectedIndex)" autocomplete="off">
                <option value="fundoQuadrado">Quadrado</option>
                <option value="fundoCirculo">Círculo</option>
                <option value="fundoCoracao">Coração</option>
                <option value="fundoEstrela">Estrela</option>
                <option value="fundoAnel">Anel</option>
                <option value="fundoCranio">Crânio</option>
                <option value="fundoAlien">Alien</option>
                <option value="fundoPikachu">Pikachu</option>
                <option value="fundoVenusaur">Venusaur</option>
                <option value="fundoBlastoise">Blastoise</option>
                <option value="fundoCharizard">Charizard</option>
                <option value="fundoFantasma">Fantasma</option>
              </select>

              <label for="numeroC"><p>Valor para a constante C:</p></label>
              <input type="number" id="numeroC" name="numeroC" step="0.01" min="1.01" max="1.60" value="1.48" autocomplete="off" />

              <label for="numeroN"><p>Valor para a variável N:</p></label>
              <input type="number" id="numeroN" name="numeroN" step="1" min="1" max="50" value="2" autocomplete="off" />

              <label for="numeroQuantidade"><p>Estampas a serem inseridas (no máximo):</p></label>
              <input type="number" id="numeroQuantidade" name="numeroQuantidade" step="10" min="50" max="2000" value="500" autocomplete="off" />

              <button class="enviar" onclick="algoritmo(selectEstampa.selectedIndex, selectFundo.selectedIndex)">
                CLIQUE PARA INICIAR
              </button>
            </div>
            <div id="objetosSvg">

              <div id="fundosSvg">

                <object id="fundoQuadrado" style="display:block" data="fundos/fundoQuadrado.svg" type="image/svg+xml"></object>
                <object id="fundoCirculo" style="display:none" data="fundos/fundoCirculo.svg" type="image/svg+xml"></object>
                <object id="fundoCoracao" style="display:none" data="fundos/fundoCoracao.svg" type="image/svg+xml"></object>
                <object id="fundoEstrela" style="display:none" data="fundos/fundoEstrela.svg" type="image/svg+xml"></object>
                <object id="fundoAnel" style="display:none" data="fundos/fundoAnel.svg" type="image/svg+xml"></object>
                <object id="fundoCranio" style="display:none" data="fundos/fundoCranio.svg" type="image/svg+xml"></object>
                <object id="fundoAlien" style="display:none" data="fundos/fundoAlien.svg" type="image/svg+xml"></object>
                <object id="fundoPikachu" style="display:none" data="fundos/fundoPikachu.svg" type="image/svg+xml"></object>
                <object id="fundoVenusaur" style="display:none" data="fundos/fundoVenusaur.svg" type="image/svg+xml"></object>
                <object id="fundoBlastoise" style="display:none" data="fundos/fundoBlastoise.svg" type="image/svg+xml"></object>
                <object id="fundoCharizard" style="display:none" data="fundos/fundoCharizard.svg" type="image/svg+xml"></object>
                <object id="fundoFantasma" style="display:none" data="fundos/fundoFantasma.svg" type="image/svg+xml"></object>

              </div>

              <div id="painelPrincipal"></div>

              <div class="form-style-6">
                <button id="salvar" style="display:none" class="enviar" onclick="salvar(selectFundo.selectedIndex)">
                  SALVAR
                </button>
              </div>

            </div>

          </center>

        </section>

      </article>

      <footer>

        <section class="fluid footerSection zeroMargin_desktop zeroMargin_tablet">
          <p class="paraContent footerTextContainer" id="data"></p>
        </section>

        <script type="text/javascript">
          var d = new Date();
          var n = d.getFullYear();
          document.getElementById("data").innerHTML = "Mosáico Fractal © Giordanna De Gregoriis - " + n;
        </script>

      </footer>

    </div>

    <script type="text/javascript">

      /* VARIÁVEIS GLOBAIS: nome das estampas, dos fundos, referência pra div das estampas e dos fundos */
      var nomeEstampas = [],
      nomeFundos = [],
      fundosSvg = document.getElementById("fundosSvg"),
      estampasDados = {
        "estampaCirculo": [0, 0 ,50],
        "estampaQuadrado": [ [-50,-50], [-50,50], [50,50], [50,-50] ],
        "estampaTriangulo": [ [-54.807,21.07], [41.785,46.951], [15.904,-49.641] ]
      },
      listaFormas = [];


      // preenche o array com os nomes das estampas
      for(var i = 0; i < document.getElementById("selectEstampa").options.length; i++) {
        nomeEstampas.push(document.getElementById("selectEstampa").options[i].value);
      }

      // preenche o array com os nomes dos fundos
      for(var i = 0; i < document.getElementById("selectFundo").options.length; i++) {
        nomeFundos.push(document.getElementById("selectFundo").options[i].value);
      }

      /*
      quando o usuário escolhe um outro fundo, deixa este visível e
      apaga os outros. também verifica se o painel está preenchido,
      e o reinicia
      */
      function mudarFundo(fundoIdx) {

        if( ! $('#painelPrincipal').is(':empty') ) {
          $('#painelPrincipal').html('');
          document.getElementById('salvar').style.display = "none";
          document.getElementById('fundosSvg').style.display = "block";
        }

        for (var i = 0 ; i < nomeFundos.length ; i++) {

          if (i == fundoIdx) {
            document.getElementById(nomeFundos[i]).style.display = 'block';
          }
          else {
            document.getElementById(nomeFundos[i]).style.display = 'none';
          }

        }

      }


      function resetarFundo(fundoIdx) {
        if( ! $('#painelPrincipal').is(':empty') ) {
          $('#painelPrincipal').html('');
          document.getElementById('salvar').style.display = "none";
          document.getElementById('fundosSvg').style.display = "block";
          document.getElementById(nomeFundos[fundoIdx]).style.display = 'block';
        }
      }

      function salvar(fundoIdx) {

        saveSvgAsPng(document.getElementById("svgPrincipal"),  "mosaico_" + nomeFundos[fundoIdx] + ".png", {scale: 10, backgroundColor: "#FFFFFF", encoderOptions: 1});

      }

      /* FUNÇÕES PARA ALTERAR POLÍGONO DE ESTAMPA */
      function centroidePoligono(poligono) {

        var x = 0, y = 0;
        for (var i = 0 ; i < poligono.length ; i++) {
          x += poligono[i][0];
          y += poligono[i][1];
        }
        return [x / poligono.length * 1.0, y / poligono.length * 1.0];


      }

      function transladaPoligono(poligono, x, y) {
        var temp = [];
        for (var i = 0 ; i < poligono.length ; i++) {
          temp.push([poligono[i][0] + x, poligono[i][1] + y]);
        }
        return temp;
      }

      function escalaForma(tipoEstampa, forma, escala) {
        if (tipoEstampa == "estampaCirculo") {
          return [forma[0], forma[1], forma[2] * escala];
        }
        else {
          return escalaPoligono(forma, escala);
        }
      }

      function transladaForma(tipoEstampa, forma, x, y) {

        if (tipoEstampa == "estampaCirculo") {
          return [forma[0] + x, forma[1] + y, forma[2]];
        }
        else {
         return transladaPoligono(forma, x, y);
        }
      }

      function rotacionaForma(tipoEstampa, forma, angulo) {

        if (tipoEstampa == "estampaCirculo") {
          return forma;
        }
        else {
          return rotacionaPoligono(forma, angulo);
        }
      }

      function escalaPoligono(poligono, s) {
        var centroide = centroidePoligono(poligono);

        var temp = transladaPoligono(poligono, -centroide[0], -centroide[1]);

        for (var i = 0 ; i < temp.length ; i++) {
          temp[i] = [temp[i][0] * s, temp[i][1] * s];
        }
        return transladaPoligono(temp, centroide[0], centroide[1]);
      }

      function rotacionaPoligono(poligono, angulo) {
        var centroide = centroidePoligono(poligono),
        x, y,
        cos = Math.cos(angulo),
        sen = Math.sin(angulo),
        temp = transladaPoligono(poligono, -centroide[0], -centroide[1]);

        for (var i = 0 ; i < temp.length ; i++) {
          x = temp[i][0] * cos - temp[i][1] * sen;
          y = temp[i][0] * sen + temp[i][1] * cos;
          temp[i] = [x,y];
        }
        return transladaPoligono(temp, centroide[0], centroide[1]);
      }

      function pathToPoints(path, samples){

        var tamanho = path.getTotalLength(),
            passo = tamanho/samples,
            pontos = [],
            ponto;

        for (var i = 0 ; i < tamanho ; i += passo ) {
          ponto = path.getPointAtLength(i);
          pontos.push([ponto.x, ponto.y]);
        }

        return pontos;

      }

      function pathParaArray(pathNome) {
        var path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute("d", document.getElementById(pathNome).getAttribute("d"));

        return pathToPoints(path, 100);
      }

      // insere valores no circulo
      function positionCircle(circle) {
        circle.attr("cx", function(d) { return d[0]; })
        .attr("cy", function(d) { return d[1]; });
      }

      // insere valores do poligono
      function positionPath(path) {
        path.attr("d", function(d) { return "M" + d.join("L") + "Z"; });
      }

      /* INÍCIO: código para verificar se círculo está dentro do polígono */

      function estaDentro(tipoEstampa, forma, arrayFundo) {

        if (tipoEstampa == "estampaCirculo") {
          return circuloDentro(forma, arrayFundo);
        }
        else {
          return poligonoDentro(forma, arrayFundo);
        }
      }

      /* função nova para testar múltiplos poligonos, com classes 'base' e 'ajuda' */
      function estaDentroPoligonos(tipoEstampa, forma, poligonosFundo) {
        var dentro = false;

        for (var i = 0 ; i < poligonosFundo.length ; i++) {
          if (poligonosFundo[i][0] == "base") {
            if (estaDentro(tipoEstampa, forma, poligonosFundo[i][1])) {
              dentro = true;
            }
          }
          else {
            if (estaTocando(tipoEstampa, forma, poligonosFundo[i][1])) {
              return false;
            }
          }
        }

        return dentro;

      }

      function estaTocando(tipoEstampa, forma, poligonoFundo) {
        if (tipoEstampa == "estampaCirculo") {
          return interseccaoCirculo(forma, poligonoFundo);
        }
        else {
          return interseccaoPoligono(forma, poligonoFundo);
        }
      }


      function poligonoDentro(polygonTest, polygon) {

        for (var i = 0 ; i < polygonTest.length ; i++) {
          if (!pointInPolygon(polygonTest[i], polygon)) {
            return false;
          }
        }
        return true;
      }

      function interseccaoPoligono(polygon1, polygon2) {

        // testa se pontos estão dentro do poligono
        for (var i = 0 ; i < polygon1.length ; i++) {
          if (pointInPolygon(polygon1[i], polygon2)) {
            return true;
          }
        }

        // testa se arestas estão dentro do polígono
        var temp1 = polygon1.slice(),
            temp2 = polygon2.slice();

        temp1.push(polygon1[0]);
        temp2.push(polygon2[0]);

        for (var i = 0 ; i < temp2.length - 1; i++) {
          for (var j = 0 ; j < temp1.length - 1; j++) {
            if (interseccaoDuasLinhas([temp1[j], temp1[j + 1]], [temp2[i], temp2[i + 1]])) {
              return true;
            }
          }
        }
        return false;
      }

      function interseccaoDuasLinhas(linha1, linha2) {
        var m1 = (linha1[1][1]-linha1[0][1]) / (linha1[1][0]-linha1[0][0]),
            m2 = (linha2[1][1]-linha2[0][1]) / (linha2[1][0]-linha2[0][0]);

        if (m1 == m2) return false;

        var cx = ((linha1[0][1] - (linha1[0][0] * m1)) - (linha2[0][1] - (linha2[0][0] * m2))) / (m2 - m1);
        return ((cx >= Math.min(linha1[0][0], linha1[1][0]) && cx <= Math.max(linha1[0][0], linha1[1][0])) && (cx >= Math.min(linha2[0][0], linha2[1][0]) && cx <= Math.max(linha2[0][0], linha2[1][0])));
        }

        function circuloDentro(circle, polygon) {
        return pointInPolygon(circle, polygon)
        && !polygonEdges(polygon).some(function(line) { return pointLineSegmentDistance(circle, line) < circle[2]; });
        }

        function interseccaoCirculo(circle, polygon) {
        return pointInPolygon(circle, polygon)
        || polygonEdges(polygon).some(function(line) { return pointLineSegmentDistance(circle, line) < circle[2]; });
      }

      function interseccaoDoisCirculos(circle1, circle2) {

        var deltax = Math.abs(circle2[0] - circle1[0]),
        deltay;

        if (deltax < (circle2[2] + circle1[2])) {

          deltay = Math.abs(circle2[1] - circle1[1]);
          if (deltay < (circle2[2] + circle1[2])) {
            return (Math.sqrt(Math.pow(circle1[0] - circle2[0], 2) + Math.pow(circle1[1] - circle2[1], 2)) >= (circle2[2] + circle1[2]));
          }
        }

        return true;
      }

      function interseccaoForma(tipoEstampa, forma1, forma2) {
        if (tipoEstampa == "estampaCirculo")
          return !interseccaoDoisCirculos(forma1, forma2);
        else
          return interseccaoPoligono(forma1, forma2);
      }

      function polygonEdges(polygon) {
        return polygon.map(function(p, i) {
          return i ? [polygon[i - 1], p] : [polygon[polygon.length - 1], p];
        });
      }

      function pointInPolygon(point, polygon) {
        for (var n = polygon.length, i = 0, j = n - 1, x = point[0], y = point[1], inside = false; i < n; j = i++) {
          var xi = polygon[i][0], yi = polygon[i][1],
          xj = polygon[j][0], yj = polygon[j][1];

          if ((yi > y != yj > y) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        return inside;
      }

      function pointLineSegmentDistance(point, line) {
        var v = line[0], w = line[1], d, t;
        return Math.sqrt(pointPointSquaredDistance(point, (d = pointPointSquaredDistance(v, w))
          ? ((t = ((point[0] - v[0]) * (w[0] - v[0]) + (point[1] - v[1]) * (w[1] - v[1])) / d) < 0 ? v
            : t > 1 ? w
            : [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])])
          : v));
      }

      function pointPointSquaredDistance(v, w) {
        var dx = v[0] - w[0], dy = v[1] - w[1];
        return dx * dx + dy * dy;
      }
      /* FIM: código para verificar se círculo está dentro do polígono */

      function corAleatoria(faixa) {
        var rgb = [];
        rgb.push(Math.floor(Math.random() * faixa));  // red
        rgb.push(Math.floor(Math.random() * faixa));  // green
        rgb.push(Math.floor(Math.random() * faixa));  // blue

        // Console.WriteLine("{0},{1},{2}", rgb[0], rgb[1], rgb[2]);

        // find max and min indexes.
        var max, min;

        if (rgb[0] > rgb[1]){
          max = (rgb[0] > rgb[2]) ? 0 : 2
          min = (rgb[1] < rgb[2]) ? 1 : 2;
        }
        else{
          max = (rgb[1] > rgb[2]) ? 1 : 2;
          var notmax = 1 + max % 2;
          min = (rgb[0] < rgb[notmax]) ? 0 : notmax;
        }
        rgb[max] = faixa - 1;
        rgb[min] = 0;

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        return rgbToHex(rgb[0], rgb[1], rgb[2]);

      }


      // função zeta de Hurwitz
      function funcaoZeta(c, N) {

        var soma = 0,
        NMAX = 100000;

        for (var i = N; i < NMAX; i++) {
          soma += Math.pow(i, -c);
        }

        return soma + soma_estimada(c, NMAX);
      }

      // valor utilizado na função zeta
      function soma_estimada(c, NMAX) {

        return (1.0 / (c - 1)) * Math.pow(NMAX, 1 - c);
      }

      // valor utilizado ao longo da execução
      function valorControle(N, expoente) {

        return Math.pow(N, -expoente);
      }

      function algoritmo(estampaIdx, fundoIdx) {

        listaFormas = [];

        // apaga o fundo escolhido visível
        document.getElementById(nomeFundos[fundoIdx]).style.display = 'none';

        document.getElementById('fundosSvg').style.display = "none";

        // pega a(s) path(s) do fundo
        var fundoSvg = document.getElementById(nomeFundos[fundoIdx]).contentDocument;

        var pathsFundo = fundoSvg.getElementsByTagName('path');

        // monta array de poligonos do fundo, com suas classes
        var poligonosFundo = [];

        for (var i = 0 ; i < pathsFundo.length ; i++) {
          poligonosFundo.push([pathsFundo[i].getAttribute("class"), pathToPoints(pathsFundo[i], 200)]);
        }

        // pega o array da estampa
        var arrayEstampa = estampasDados[nomeEstampas[estampaIdx]];

        var tipoEstampa = nomeEstampas[estampaIdx];

        var tipoFundo = nomeFundos[fundoIdx];

        // reinicia o painel
        if( ! $('#painelPrincipal').is(':empty') ) {
          $('#painelPrincipal').html('');
          document.getElementById('salvar').style.display = "none";
        }

        // declara variáveis que serão utilizadas para o preenchimento
        var razaoDaArea,
        constante,
        expoente,
        N = 3;

        constante = document.getElementById("numeroC").value;
        N = document.getElementById("numeroN").value;

        // calcula valores a serem utilizados nesta execução: razão e expoente
        razaoDaArea = 1.0 / funcaoZeta(constante, N);
        expoente = 0.5 * constante;

        // quando terminar o preenchimento, mostrar botão de salvar
        $.when(preencherArea()).then( function (x) {
          document.getElementById('salvar').style.display = "block";
        });


        function preencherArea() {

          var x,
          y,
          escala,
          largura = 100,
          altura = 100,
          numeroFormas = 0,
          numeroIteracoes = 0,
          maxIteracoes = 1000,
          maxFormas = document.getElementById("numeroQuantidade").value;

          // acesso ao svg de pintura
          var painelPrincipal = d3.select("#painelPrincipal").append("svg")
          .attr("id", "svgPrincipal")
          .attr("xmlns", "http://www.w3.org/2000/svg")
          .attr("preserveAspectRatio", "xMinYMin meet")
          .attr("viewBox", "0 0 100 100")
          .attr("width", "600")
          .attr("height", "600");

          // cor a ser usada na execução
          var cor = corAleatoria(156);

          //d3.timer(function() {
            do {

              // gera forma
              var forma = gerarForma();

              // só para de executar assim??
              if (numeroFormas > maxFormas || numeroIteracoes > maxIteracoes) break;

              if (forma != null) {


                // adiciona forma
                if (nomeEstampas[estampaIdx] == "estampaCirculo") {
                  // círculo
                  painelPrincipal.append("circle")
                  .datum(forma)
                  .call(positionCircle)
                  .attr('class', "")
                  .style("fill", cor)
                  .style("fill-opacity", (Math.random() + .5) / 2)
                  //.attr("r", "0")
                  //.transition()
                  .attr("r", function(d) { return d[2]; });
                }
                else {
                  // outros
                  painelPrincipal.append("path")
                  .datum(forma)
                  .attr('class', "")
                  .style("fill", cor)
                  .style("fill-opacity", (Math.random() + .5) / 2)
                  .call(positionPath);
                }

                listaFormas.push(forma);

                N++;
                numeroFormas++;
              }
              else {
                // limite de tentativas de posicionar atingido... será que assim para??
                numeroIteracoes = maxIteracoes + 1;
                numeroFormas = maxFormas + 1;
                break;
              }


            } while (numeroFormas < maxFormas && numeroIteracoes < maxIteracoes);

          //});

          listaFormas = [];

          function gerarForma() {

            // gera valor de escala
            escala = razaoDaArea * valorControle(N, expoente);
            numeroIteracoes = 0;

            var forma,
            formaTransladada,
            formaValida,
            ponto;

            forma = escalaForma(tipoEstampa, arrayEstampa, escala);


            while (numeroIteracoes < maxIteracoes) {

              formaValida = true;

              formaTransladada =  encontrarXY(forma);

              if (x == -1 && y == -1) {
                if (numeroFormas == 0) { // se nem a primeira forma consegue ser inserida, diminua o N
                  N++;
                }
                return null;
              }

              for (var i = 0 ; i < listaFormas.length ; i++) {
                if (interseccaoForma(tipoEstampa, formaTransladada, listaFormas[i])) {
                  formaValida = false;
                  break;
                }
              }

              if (formaValida) {
                return formaTransladada;
              }

              numeroIteracoes++;

            }

            return null;
          }

          function encontrarXY(forma) {
            x = Math.random() * largura,
            y = Math.random() * altura;

            var iteracoes_posicao = 0;

            var copiaForma = rotacionaForma(tipoEstampa, forma, Math.random() * 2 * Math.PI);
            copiaForma = transladaForma(tipoEstampa, copiaForma, x, y);

            while ( !estaDentroPoligonos(tipoEstampa, copiaForma, poligonosFundo) ){

              x = Math.random() * largura,
              y = Math.random() * altura;

              copiaForma = rotacionaForma(tipoEstampa, forma, Math.random() * 2 * Math.PI);
              copiaForma = transladaForma(tipoEstampa, copiaForma, x, y);

              iteracoes_posicao++;
              if (iteracoes_posicao > maxIteracoes) {
                // passou do limite
                x = -1; y = -1;
                return;
              }
            }
              // se chegou aqui, x e y são válidos

            return copiaForma;
          }
        }

      }
    </script>

  </body>

  </html>
